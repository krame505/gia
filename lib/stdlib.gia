# gia standard util

# Maybe
datatype Maybe = {hasValue: bool, value, cond: bool, and: (any) -> any, or: (any) -> any, not: bool};

Some(x): Maybe {
  hasValue = true;
  value = x;
  cond = true;
  and = fn(m) (m);
  or = fn(m) (self);
  not = false;
};

None(): Maybe {
  hasValue = false;
  value = error("Demanded value from None");
  cond = false;
  and = fn(m) (false);
  or = fn(m) (m);
  not = true;
};

# List

# Util functions
map(f: (any) -> any, items: any*): any*
  if items
  then f(items.hd) :: map(f, items.tl)
  else [];

filter(f: (any) -> bool, items: any*): any* {
  rest = filter(f, items.tl);
  return
    if items.null
    then []
    else if f(items.hd)
    then items.hd :: rest
    else rest;
};

containsBy(f: (any, any) -> bool, x, items: any*): bool
  !items.null & (f(items.hd, x) | containsBy(f, x, items.tl));

range(lower : int, upper : int) : int*
  if lower >= upper
  then []
  else lower :: range(lower + 1, upper);

# Set
inSet(x, s : any%) s == (s | set {x});

# Map
datatype MapEntry = {key, value, eq: (any) -> bool}; # TODO: Fix bug with parameter type names missing
datatype Map = {entries: MapEntry%, index: (any) -> any};

MapEntry(k, v): MapEntry {
  key = k;
  value = v;
  eq = fn(other) (other == key);
};

Map(ks, vs): Map {
  entries =
    if ks.null
    then set {}
    else put(ks.hd, vs.hd, Map(ks.tl, vs.tl));
  index = fn(x)(get(x, self));
};

MapFromSet(s): Map {
  entries = s;
  index = fn(x)(get(x, self));
};

put(k, v, m: Map)
  MapFromSet(set {(MapEntry(k, v))} | m.entries);

inMap(k, m: Map) : bool
  m.entries[k].value.hasValue;

get(k, m: Map)
  m.entries[k].value.value;

# Pair
# Note: This is going away eventually when there is a proper tuple extension
datatype Pair = {fst, snd};
Pair(fst, snd) : Pair {
  fst = fst;
  snd = snd;
};

fst(p : Pair) p.fst;
snd(p : Pair) p.snd;

# String
toStr(x) x.toStr;
pp(x) x.pp;

implode(sep : str, list : str*) : str
  if list.null
  then ""
  else if list.tl.null
  then list.hd
  else list.hd + sep + implode(sep, list.tl);

explode(sep : str, s : str) : str* {
  helper(index, matchIndex, between, match)
    if index == s.len
    then [between + match]
    else if matchIndex == sep.len
    then between :: helper(index + 1, 0, s[index], "")
    else if s[index] == (sep[matchIndex])
    then helper(index + 1, matchIndex + 1, between, match + s[index])
    else helper(index + 1, 0, between + match + s[index], "");
  
  return helper(0, 0, "", "");
};